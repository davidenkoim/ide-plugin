package reporting

import com.intellij.openapi.diagnostic.SubmittedReportInfo
import com.intellij.openapi.diagnostic.SubmittedReportInfo.SubmissionStatus
import org.eclipse.egit.github.core.Issue
import org.eclipse.egit.github.core.Label
import org.eclipse.egit.github.core.RepositoryId
import org.eclipse.egit.github.core.client.GitHubClient
import org.eclipse.egit.github.core.service.IssueService
import utils.MessageBundle
import enums.ReportInformationType.*
import utils.CryptoUtils
import java.util.*

/**
 * Provides functionality to create and send GitHub issues when an exception is thrown by a plugin
 */
internal object AnonymousFeedback {
    private const val TOKEN = "token.bin"
    private const val GIT_REPO_USER = "ml-in-programming"
    private const val GIT_REPO = "astrid"
    private const val ISSUE_LABEL_BUG = "bug"
    private const val ISSUE_LABEL_AUTO_GENERATED = "auto-generated"
    private const val GIT_ISSUE_TITLE = "[auto-generated:%s] %s"
    private const val HTML_URL_TO_CREATE_NEW_ISSUE = "https://github.com/ml-in-programming/astrid/issues/new"
    private val paramsNames = mutableMapOf(
            PLUGIN_NAME to "Plugin Name",
            PLUGIN_VERSION to "Plugin Version",
            OS_NAME to "OS Name",
            JAVA_VERSION to "Java Version",
            JAVA_VM_VENDOR to "Java VM Vendor",
            APP_NAME to "App Name",
            APP_FULL_NAME to "App Full Name",
            APP_VERSION_NAME to "App Version Name",
            IS_EAP to "Is EAP",
            APP_BUILD to "App Build",
            APP_VERSION to "App Version",
            LAST_ACTION to "Last EventType",
            PERMANENT_INSTALLATION_ID to "User's Permanent Installation ID")

    fun sendFeedback(errorReportInformation: ErrorReportInformation): SubmittedReportInfo {
        val result: SubmittedReportInfo
        try {
            val gitAccessToken = CryptoUtils.decryptAES256String((AnonymousFeedback::class.java.classLoader.getResourceAsStream(TOKEN)))
            val client = GitHubClient()
            client.setOAuth2Token(gitAccessToken)
            val repoID = RepositoryId(GIT_REPO_USER, GIT_REPO)
            val issueService = IssueService(client)
            var newGibHubIssue = createNewGibHubIssue(errorReportInformation)
            val duplicate = findFirstDuplicate(newGibHubIssue.title, issueService, repoID)
            var isNewIssue = true
            if (duplicate != null) {
                val newErrorComment = generateGitHubIssueBody(errorReportInformation, false)
                issueService.createComment(repoID, duplicate.number, newErrorComment)
                newGibHubIssue = duplicate
                isNewIssue = false
            } else {
                newGibHubIssue = issueService.createIssue(repoID, newGibHubIssue)
            }
            val id = newGibHubIssue.number
            val htmlUrl = newGibHubIssue.htmlUrl
            val message = MessageBundle.message(if (isNewIssue) "git.issue.text" else "git.issue.duplicate.text", htmlUrl, id)
            result = SubmittedReportInfo(htmlUrl, message, if (isNewIssue) SubmissionStatus.NEW_ISSUE else SubmissionStatus.DUPLICATE)
            return result
        } catch (e: Exception) {
            return SubmittedReportInfo(HTML_URL_TO_CREATE_NEW_ISSUE,
                    MessageBundle.message("report.error.connection.failure", HTML_URL_TO_CREATE_NEW_ISSUE),
                    SubmissionStatus.FAILED)
        }
    }

    private fun findFirstDuplicate(uniqueTitle: String, service: IssueService, repo: RepositoryId): Issue? {
        val searchParameters = HashMap<String, String>(2)
        searchParameters[IssueService.FILTER_STATE] = IssueService.STATE_OPEN
        return service.pageIssues(repo, searchParameters).flatten().firstOrNull { it.title == uniqueTitle }
    }

    private fun createNewGibHubIssue(errorReportInformation: ErrorReportInformation): Issue {
        var errorMessage: String? = errorReportInformation[ERROR_MESSAGE]
        if (errorMessage.isNullOrEmpty()) {
            errorMessage = "Unspecified error"
        }
        var errorHash: String? = errorReportInformation[ERROR_HASH]
        if (errorHash == null) {
            errorHash = ""
        }

        val gitHubIssue = Issue()
        gitHubIssue.title = String.format(GIT_ISSUE_TITLE, errorHash, errorMessage)
        gitHubIssue.body = generateGitHubIssueBody(errorReportInformation, true)
        val bugLabel = Label()
        bugLabel.name = ISSUE_LABEL_BUG
        val autoGeneratedLabel = Label()
        autoGeneratedLabel.name = ISSUE_LABEL_AUTO_GENERATED
        gitHubIssue.labels = Arrays.asList(autoGeneratedLabel, bugLabel)
        return gitHubIssue
    }

    private fun generateGitHubIssueBody(errorReportInformation: ErrorReportInformation, addStacktrace: Boolean): String {
        var errorDescription: String? = errorReportInformation[ERROR_DESCRIPTION]
        if (errorDescription == null) {
            errorDescription = ""
        }
        var stackTrace: String? = errorReportInformation[ERROR_STACKTRACE]
        if (stackTrace.isNullOrEmpty()) {
            stackTrace = "invalid stacktrace"
        }

        val result = StringBuilder()

        if (errorDescription.isNotEmpty()) {
            result.append(errorDescription)
            result.append("\n")
        }
        for ((key, value) in paramsNames) {
            result.append("- ")
            result.append(value)
            result.append(": ")
            result.append(errorReportInformation[key])
            result.append("\n")
        }

        if (addStacktrace) {
            result.append("\n```\n")
            result.append(stackTrace)
            result.append("\n```\n")
        }

        return result.toString()
    }
}